from RWESharp.Modify import Editor
from RWESharp.Core import CELLSIZE, SPRITESIZE
from RWESharp.Configurable import KeyConfigurable
from RWESharp.Loaders import Prop
from RWESharp.Core import lingoIO
from RWESharp.Renderable import RenderLine, RenderPoly

from BaseMod.props.propExplorer import PropExplorer
from BaseMod.props.propRenderable import PropRenderable
from BaseMod.props.propHistory import PropPlace, PropRemove
from BaseMod.props.propUtils import find_mid

from PySide6.QtCore import QPointF, QLineF
from PySide6.QtGui import QPolygonF

import random as rnd


class PropEditor(Editor):
    def __init__(self, mod):
        super().__init__(mod)
        self.props = self.manager.props
        self.explorer = PropExplorer(self, self.manager.window)
        self.prop: Prop = self.props.find_prop("loopantennafront")
        self.placingprop = PropRenderable(self, self.prop)
        self.depth = 0
        self.notes = []
        self.setprop([self.props.find_prop("CogA1")])
        self.prop_settings = {"renderorder": 0, "seed": rnd.randint(0, 1000), "renderTime": 0}
        self.editingprop = False
        self.debugline = RenderLine(self, 0, QLineF())
        self.debugpoly = RenderPoly(self, 0, QPolygonF())

    def setprop(self, props: list[Prop]):
        if len(props) > 0:
            self.prop = props[0]
        self.placingprop.setprop(self.prop)
        self.applysettings()
        self.reset_transform()

    def move_event(self, pos):
        super().move_event(pos)
        if not self.editingprop:
            self.placingprop.setPos(self.viewport.viewport_to_editor_float(self.mouse_pos.toPointF()) * CELLSIZE)
        self.debugline.drawline.setOpacity(0)
        self.debugpoly.drawpoly.setOpacity(0)
        if self.shift:
            self.debugline.drawline.setOpacity(1)
            self.debugpoly.drawpoly.setOpacity(1)
            closest = self.level.l_props[self.find_nearest(self.mouse_pos)]
            self.debugline.setLine(QLineF(self.viewport.viewport_to_editor_float(self.mouse_pos.toPointF()) * CELLSIZE, find_mid(closest)))
            self.debugpoly.setPoly(QPolygonF(closest[3]))

    def mouse_left_press(self):
        if not self.shift:
            self.place()
            return
        closest = self.find_nearest(self.mouse_pos)
        self.level.add_history(PropRemove(self.level.history, closest))

    def free_transform(self):
        if self.editingprop:
            self.editingprop = False
            self.placingprop.delete_handlers()
            self.viewport.clean()
            return
        self.editingprop = True
        self.placingprop.free_transform()
        self.viewport.clean()

    def find_nearest(self, pos):
        closesti = -1
        closest = 99999
        for i, v in enumerate(self.level.l_props):
            p = (find_mid(v) - self.viewport.viewport_to_editor_float(self.mouse_pos.toPointF()) * CELLSIZE).manhattanLength()
            if p < closest:
                closest = p
                closesti = i
        return closesti

    def reset_transform(self):
        w, h, = self.prop.size.width() / 2, self.prop.size.height() / 2
        self.transform = [QPointF(-w, -h), QPointF(w, -h), QPointF(w, h), QPointF(-w, h)]

    @property
    def transform(self) -> [QPointF, QPointF, QPointF, QPointF]:
        return self.placingprop.transform

    @transform.setter
    def transform(self, value: [QPointF, QPointF, QPointF, QPointF]):
        self.placingprop.transform = value

    def applysettings(self):
        self.prop_settings = {"renderorder": 0, "seed": rnd.randint(0, 1000), "renderTime": 0}
        random = self.prop["random"] if self.prop.get("random") is not None else 1
        notes = self.prop.notes.copy()
        if self.prop.type in ["standard", "variedStandard"]:
                if self.prop.colorTreatment == "bevel":
                    notes.append("The highlights and shadows on this prop are generated by code,\nso it can be rotated to any degree and they will remain correct.\n")
                else:
                    notes.append("Be aware that shadows and highlights will not rotate with the prop,\nso extreme rotations may cause incorrect shading.\n")
                if self.prop.type == "variedStandard":
                    self.prop_settings["variation"] = 0 if random else 1

                if random:
                    notes.append("Will put down a random variation.\nA specific variation can be selected from settings.\n")
                else:
                    notes.append("This prop comes with many variations.\nWhich variation can be selected from settings.\n")
        elif self.prop.type == "rope":
                self.prop_settings["release"] = 0
        elif self.prop.type in ["variedDecal", "variedSoft"]:
            self.prop_settings["variation"] = 0 if random else 1
            self.prop_settings["customDepth"] = self.prop.get("depth")
            if self.prop.type == "variedSoft" and self.prop.get("colorize"):
                self.prop_settings["applyColor"] = 1
                notes.append("It's recommended to render this prop after the effects\nif the color is activated, as the effects won't affect the color layers.\n")
        elif self.prop.type in ["simpleDecal", "soft", "softEffect", "antimatter"]:
            self.prop_settings["customDepth"] = self.prop["depth"]

        if self.prop.type in ["soft", "softEffect", "variedSoft"]:
            if self.prop.get("selfShade") == 1:
                notes.append("The highlights and shadows on this prop are generated by code,\nso it can be rotated to any degree and they will remain correct.\n")
            else:
                notes.append("Be aware that shadows and highlights will not rotate with the prop,\nso extreme rotations may cause incorrect shading.\n")
        if self.prop.name.lower() in ["wire", "zero-g wire"]:
            self.prop_settings["thickness"] = 2
            notes.append("The thickness of the wire can be set in settings.\n")
        elif self.prop.name.lower() in ["zero-g tube"]:
            self.prop_settings["applyColor"] = 0
            notes.append("The tube can be colored white through the settings.\n")
        for tag in self.prop.tags:
            match tag:
                case "customColor":
                    self.prop_settings["color"] = 0
                    notes.append("Custom color available\n")
                case "customColorRainBow":
                    self.prop_settings["color"] = 1
                    notes.append("Custom color available\n")
        newnotes = []
        for note in self.notes:
            if note in newnotes:
                pass
            else:
                newnotes.append(note)
        self.notes = notes

    def place(self):
        quads = [i + self.placingprop.offset for i in self.transform]
        prop = [-self.depth, self.prop.name, lingoIO.point([self.prop.cat.x(), self.prop.cat.y()]),
                quads, {"settings": self.prop_settings.copy()}]
        self.level.add_history(PropPlace(self.level.history, prop))
