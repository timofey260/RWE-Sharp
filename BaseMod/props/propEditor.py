from RWESharp.Modify import Editor
from RWESharp.Core import CELLSIZE, SPRITESIZE
from RWESharp.Configurable import KeyConfigurable
from RWESharp.Loaders import Prop
from RWESharp.Core import lingoIO

from BaseMod.props.propExplorer import PropExplorer
from BaseMod.props.propRenderable import PropRenderable
from BaseMod.props.propHistory import PropPlace

from PySide6.QtGui import QGuiApplication
from PySide6.QtCore import QPointF

import random as rnd


class PropEditor(Editor):
    def __init__(self, mod):
        super().__init__(mod)
        self.props = self.manager.props
        self.explorer = PropExplorer(self, self.manager.window)
        self.prop: Prop = self.props.find_prop("loopantennafront")
        self.placingprop = PropRenderable(mod, self.prop).add_myself(self)
        self.depth = 0
        self.notes = []
        self.setprop([self.props.find_prop("CogA1")])

    def setprop(self, props: list[Prop]):
        if len(props) > 0:
            self.prop = props[0]
        self.placingprop.setprop(self.prop)
        self.applysettings()

    def move_event(self, pos):
        super().move_event(pos)
        w, h, = self.prop.size.width() / 2, self.prop.size.height() / 2
        self.transform = [QPointF(-w, -h), QPointF(w, -h), QPointF(w, h), QPointF(-w, h)]
        self.placingprop.setPos(self.viewport.viewport_to_editor_float(self.mouse_pos.toPointF()) * CELLSIZE)

    def mouse_left_press(self):
        super().mouse_left_press()
        self.place()

    @property
    def transform(self) -> [QPointF, QPointF, QPointF, QPointF]:
        return self.placingprop.transform

    @transform.setter
    def transform(self, value: [QPointF, QPointF, QPointF, QPointF]):
        self.placingprop.transform = value

    def applysettings(self):
        self.prop_settings = {"renderorder": 0, "seed": rnd.randint(0, 1000), "renderTime": 0}
        random = self.prop["random"] if self.prop.get("random") is not None else 1
        notes = self.prop.notes.copy()
        if self.prop.type in ["standard", "variedStandard"]:
                if self.prop.colorTreatment == "bevel":
                    notes.append("The highlights and shadows on this prop are generated by code,\nso it can be rotated to any degree and they will remain correct.\n")
                else:
                    notes.append("Be aware that shadows and highlights will not rotate with the prop,\nso extreme rotations may cause incorrect shading.\n")
                if self.prop.type == "variedStandard":
                    self.prop_settings["variation"] = 0 if random else 1

                if random:
                    notes.append("Will put down a random variation.\nA specific variation can be selected from settings.\n")
                else:
                    notes.append("This prop comes with many variations.\nWhich variation can be selected from settings.\n")
        elif self.prop.type == "rope":
                self.prop_settings["release"] = 0
        elif self.prop.type in ["variedDecal", "variedSoft"]:
            self.prop_settings["variation"] = 0 if random else 1
            self.prop_settings["customDepth"] = self.prop.get("depth")
            if self.prop.type == "variedSoft" and self.prop.get("colorize"):
                self.prop_settings["applyColor"] = 1
                notes.append("It's recommended to render this prop after the effects\nif the color is activated, as the effects won't affect the color layers.\n")
        elif self.prop.type in ["simpleDecal", "soft", "softEffect", "antimatter"]:
            self.prop_settings["customDepth"] = self.prop["depth"]

        if self.prop.type in ["soft", "softEffect", "variedSoft"]:
            if self.prop.get("selfShade") == 1:
                notes.append("The highlights and shadows on this prop are generated by code,\nso it can be rotated to any degree and they will remain correct.\n")
            else:
                notes.append("Be aware that shadows and highlights will not rotate with the prop,\nso extreme rotations may cause incorrect shading.\n")
        if self.prop.name.lower() in ["wire", "zero-g wire"]:
            self.prop_settings["thickness"] = 2
            notes.append("The thickness of the wire can be set in settings.\n")
        elif self.prop.name.lower() in ["zero-g tube"]:
            self.prop_settings["applyColor"] = 0
            notes.append("The tube can be colored white through the settings.\n")
        for tag in self.prop.tags:
            match tag:
                case "customColor":
                    self.prop_settings["color"] = 0
                    notes.append("Custom color available\n")
                case "customColorRainBow":
                    self.prop_settings["color"] = 1
                    notes.append("Custom color available\n")
        newnotes = []
        for note in self.notes:
            if note in newnotes:
                pass
            else:
                newnotes.append(note)
        self.notes = notes

    def place(self):
        quads1 = [(i + self.placingprop.offset) * (SPRITESIZE / CELLSIZE) for i in self.transform]
        quads = [lingoIO.makearr([round(i.x(), 4), round(i.y(), 4)], "point") for i in quads1]
        prop = [-self.depth, self.prop.name, lingoIO.makearr([self.prop.cat.x(), self.prop.cat.y()], "point"),
                quads, {"settings": self.prop_settings.copy()}]
        self.level.add_history(PropPlace(self.level.history, prop))
